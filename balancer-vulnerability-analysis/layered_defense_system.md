# Balancer 组合漏洞的纵深防御体系

## 1. 数学计算层加固

### 1.1 舍入策略改革
**现状**：`_downscaleDown` 使用 `FixedPoint.divDown`（向下舍入）
**问题**：在 `GIVEN_OUT` 模式下，向下舍入产生系统性偏差

**解决方案**：
```solidity
// 方案A：上下文感知的舍入
function _contextAwareRounding(uint256 amount, uint256 scalingFactor, SwapContext memory context) internal pure returns (uint256) {
    if (context.kind == SwapKind.GIVEN_OUT) {
        // GIVEN_OUT时使用向上舍入，保护协议利益
        return FixedPoint.divUp(amount, scalingFactor);
    } else {
        // GIVEN_IN时维持向下舍入，保护用户利益
        return FixedPoint.divDown(amount, scalingFactor);
    }
}

// 方案B：引入最小精度损失检查
function _withPrecisionCheck(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {
    uint256 scaled = FixedPoint.divDown(amount, scalingFactor);
    uint256 remainder = amount - scaled * scalingFactor;
    
    require(remainder <= MAX_ALLOWED_PRECISION_LOSS, "Excessive precision loss");
    return scaled;
}