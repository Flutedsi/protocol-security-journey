# Defense-in-Depth System for the Balancer Composite Vulnerability

## 1. Strengthening the Mathematical Computation Layer

### 1.1 Rounding Strategy Reform
**Current state**: `_downscaleDown` uses `FixedPoint.divDown` (rounds down)  
**Issue**: In `GIVEN_OUT` mode, rounding down produces a systemic bias

**Solutions**ï¼š
```solidity
// Proposal A: Context-aware rounding
function _contextAwareRounding(uint256 amount, uint256 scalingFactor, SwapContext memory context) internal pure returns (uint256) {
    if (context.kind == SwapKind.GIVEN_OUT) {
        // Use rounding up when GIVEN_OUT to protect protocol interests
        return FixedPoint.divUp(amount, scalingFactor);
    } else {
        // Maintain rounding down when GIVEN_IN to protect user interests
        return FixedPoint.divDown(amount, scalingFactor);
    }
}

// Proposal B: Introduce minimal precision-loss check
function _withPrecisionCheck(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {
    uint256 scaled = FixedPoint.divDown(amount, scalingFactor);
    uint256 remainder = amount - scaled * scalingFactor;
    
    require(remainder <= MAX_ALLOWED_PRECISION_LOSS, "Excessive precision loss");
    return scaled;
}
```